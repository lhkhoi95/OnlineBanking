Management: The most important factor in software work is the equality of the programmers. The best programmers are up to 28 times better than the worst programmers. Adding people to a late project makes it later. The working environment has a profound impact on productivity and quality. Tools and Techniques: Hype is the plague on the house software. New tools and techniques cause an initial lost of productivity/quality. Software Developers talk a lot about tools, but seldom use them. 
Estimation: One of the two most common causes of runaway projects is poor estimation. Software estimation usually occurs at the wrong time. Software estimation is usually done by the wrong people. Software estimates are rarely connected as the project proceeds. It is not surprising that software estimates are bad. But we live and die by them anyway! There is a disconnect between software management and their programmers. The answer to a feasibility study is almost always “yes”. 
Reuse: Reuse-in-the-small is well-solved program. Reuse-in-the-large remains a mostly unsolved problem. Reuse-in-the-large works best in families or related systems. Reusable components are three times as hard to build and should be tried out in three settings. Modification of reused code is particularly error prone. Design pattern reuse is one solution to the problems of code reuse. Complexity: For every 25% increase in problem complexity, there is a 100% increase in solution complexity. Eighty percent of software work is intellectual. A fair amount of it is creative. Little of it is clerical. 
Requirements: One of the two most common causes of runaway project is unstable requirements. Requirements errors are the most expensive to fix during production. Missing requirements are the hardest requirements errors to correct. Design: Explicit requirements “explode” as implicit (design) requirements for a solution evolve. There is a seldom one best design solution to a software problem. Design is a complex, iterative process. Initial design solutions are usually wrong and certainly not optimal Coding. Designer “primitives” (solutions programmers can readily code) rarely match programmers “primitives”. COBOL is a very bad language, but all the others (for business applications) are so much worse.
Error Removal: Error removal is the most time-consuming phase of the life cycle. 
Testing: Software is usually tested at best at the 55 – 60% coverage level. One hundred percent coverage is still far from enough. Test tools are essential, but many are rarely used. Test automation rarely is. Most testing activities can not be automated. Programmer-created, build-in debug code is an important supplement to testing tools. 
Review and inspection: Rigorous inspections can remove up to 90% of errors before the first test case is run. Rigorous inspections should not replace testing. Postdelivery reviews (some call them “retrospectives”) are important and seldom performed. Reviews are both technical and sociological, and both factors must be accommodated. 
Maintenance: Maintenance typically consumes 40-80% of software costs. It’s prob. the most important life cycle phase of software. Enhancements represent roughly 60% of maintenance costs. Maintenance is a solution, not a problem. Understanding the existing product is the most difficult task of maintenance. Better methods lead to more maintenance, not less. 
Quality: Quality is a collection of attributes. Quality is not user satisfaction, meeting requirements, achieving cost and schedule, or reliability. 
Reliability: There are errors that most programmers tend to make. Errors tend to cluster. There is no single best approach to software error removal. Residual errors will always persist. The goal should be to minimize or eliminate server errors. 
Efficiency: Efficiency stems more from good design than good coding. High-order language code can be about 90% as efficient as comparable assembler code. There are tradeoffs between size and time optimization. Many researchers advocate rather than investigate.
